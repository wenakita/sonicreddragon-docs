import React, { useEffect, useRef, useState } from 'react';
import styles from './styles.module.css';

export default function CrossChainRandomnessAnimation() {
  const animationRef = useRef(null);
  const [error, setError] = useState(null);
  const timelineRef = useRef(null);
  
  useEffect(() => {
    // Create animation only when component is mounted
    let isComponentMounted = true;
    
    // Dynamically import anime.js to avoid SSR issues
    import('animejs/lib/anime.es.js').then(animeModule => {
      if (!isComponentMounted || !animationRef.current) return;
      
      const anime = animeModule.default;
      
      // Store timeline in ref for cleanup
      timelineRef.current = anime.timeline({
        easing: 'easeOutExpo',
        duration: 3000,
        loop: true,
        autoplay: true,
      });
      
      // Step 1: Initialize the randomness request
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.chain-a-request'),
        opacity: [0, 1],
        translateY: [20, 0],
        duration: 500,
      });
      
      // Step 2: Send request to Chainlink VRF
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.request-arrow'),
        strokeDashoffset: [anime.setDashoffset, 0],
        easing: 'easeInOutSine',
        duration: 700,
      });
      
      // Step 3: Chainlink VRF processes the request
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.chainlink-node'),
        scale: [1, 1.1],
        backgroundColor: '#375BD2',
        duration: 500,
      });
      
      // Step 4: Randomness generated by Chainlink
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.chainlink-node'),
        scale: [1.1, 1],
        backgroundColor: '#2A58DA',
        duration: 500,
      });
      
      // Step 5: Response travels back
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.response-arrow'),
        strokeDashoffset: [anime.setDashoffset, 0],
        easing: 'easeInOutSine',
        duration: 700,
      });
      
      // Step 6: Send to LayerZero for cross-chain verification
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.layerzero-arrow'),
        strokeDashoffset: [anime.setDashoffset, 0],
        easing: 'easeInOutSine',
        duration: 700,
      });
      
      // Step 7: LayerZero processes the cross-chain message
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.layerzero-node'),
        scale: [1, 1.1],
        backgroundColor: '#6D00ED',
        duration: 500,
      });
      
      // Step 8: Message arrives at Chain B
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.chain-b-arrow'),
        strokeDashoffset: [anime.setDashoffset, 0],
        easing: 'easeInOutSine',
        duration: 700,
      });
      
      // Step 9: Chain B verifies and uses the randomness
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.chain-b-response'),
        opacity: [0, 1],
        translateY: [20, 0],
        duration: 500,
      });
      
      // Step 10: Add drand verification for multi-source
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.drand-arrow'),
        strokeDashoffset: [anime.setDashoffset, 0],
        easing: 'easeInOutSine',
        duration: 700,
        delay: 200,
      });
      
      // Step 11: drand processes the request
      timelineRef.current.add({
        targets: animationRef.current.querySelector('.drand-node'),
        scale: [1, 1.1],
        backgroundColor: '#F16822',
        duration: 500,
      });
      
      // Step 12: Reset for next loop
      timelineRef.current.add({
        targets: animationRef.current.querySelectorAll('.chain-a-request, .chain-b-response'),
        opacity: 0,
        duration: 500,
        delay: 800,
      });
    }).catch(err => {
      console.error('Failed to load anime.js:', err);
      if (isComponentMounted) {
        setError('Animation library failed to load');
      }
    });
    
    // Cleanup function to handle unmounting
    return () => {
      isComponentMounted = false;
      if (timelineRef.current) {
        timelineRef.current.pause();
        timelineRef.current = null;
      }
    };
  }, []);
  
  if (error) {
    return (
      <div className={styles.animationError}>
        <p>Unable to load animation: {error}</p>
        <p>Please refresh the page or try again later.</p>
      </div>
    );
  }
  
  return (
    <div className={styles.animationContainer} ref={animationRef}>
      <h3 className={styles.animationTitle}>Cross-Chain Randomness Flow</h3>
      <p className={styles.animationDescription}>
        Visualizing how OmniDragon securely generates and verifies randomness across multiple chains
      </p>
      
      <div className={styles.crossChainContainer}>
        <div className={styles.chainBox}>
          <div className={styles.chainLabel}>Chain A (Arbitrum)</div>
          <div className="chain-a-request">Randomness Request</div>
        </div>
        
        <svg className={styles.arrowSvg} width="100%" height="50">
          <path 
            className="request-arrow" 
            d="M100,25 L200,25" 
            fill="none" 
            stroke="#375BD2" 
            strokeWidth="2"
            strokeDasharray="5,5"
          />
          <polygon points="200,20 210,25 200,30" fill="#375BD2" />
        </svg>
        
        <div className={`${styles.nodeBox} chainlink-node`}>
          <div className={styles.nodeLabel}>Chainlink VRF</div>
        </div>
        
        <svg className={styles.arrowSvg} width="100%" height="50">
          <path 
            className="response-arrow" 
            d="M210,35 L100,35" 
            fill="none" 
            stroke="#375BD2" 
            strokeWidth="2"
          />
          <polygon points="100,30 90,35 100,40" fill="#375BD2" />
        </svg>
        
        <svg className={styles.arrowSvg} width="100%" height="50">
          <path 
            className="layerzero-arrow" 
            d="M100,60 L320,60" 
            fill="none" 
            stroke="#6D00ED" 
            strokeWidth="2"
          />
          <polygon points="320,55 330,60 320,65" fill="#6D00ED" />
        </svg>
        
        <div className={`${styles.nodeBox} layerzero-node`}>
          <div className={styles.nodeLabel}>LayerZero</div>
        </div>
        
        <svg className={styles.arrowSvg} width="100%" height="50">
          <path 
            className="chain-b-arrow" 
            d="M330,60 L450,60" 
            fill="none" 
            stroke="#6D00ED" 
            strokeWidth="2"
          />
          <polygon points="450,55 460,60 450,65" fill="#6D00ED" />
        </svg>
        
        <div className={styles.chainBox}>
          <div className={styles.chainLabel}>Chain B (Sonic)</div>
          <div className="chain-b-response">Verified Randomness</div>
        </div>
        
        <svg className={styles.arrowSvg} width="100%" height="50">
          <path 
            className="drand-arrow" 
            d="M100,85 L200,85" 
            fill="none" 
            stroke="#F16822" 
            strokeWidth="2"
            strokeDasharray="5,5"
          />
          <polygon points="200,80 210,85 200,90" fill="#F16822" />
        </svg>
        
        <div className={`${styles.nodeBox} drand-node`}>
          <div className={styles.nodeLabel}>drand Network</div>
        </div>
      </div>
    </div>
  );
} 
---
sidebar_position: 4
title: Vrf Utils
description: Detailed explanation of this concept
---

# VRF Utility Library

The ChainlinkVRFImplementations library provides a collection of utility functions for working with random numbers generated by verifiable random function (VRF) providers like Chainlink.

## Overview

This library offers a set of helper functions that simplify common operations when working with random numbers, such as generating numbers within specific ranges, creating multiple random numbers from a single seed, selecting random indices, and shuffling arrays.

```mermaid
flowchart TD
    A[Random Seed] -->|> B[ChainlinkVRFImplementations]
    B| C[getRandomInRange]
    B -->|> D[getMultipleRandomNumbers]
    B| E[getRandomIndices]
    B -->|> F[shuffleArray]
    C| G[Jackpot Winner Selection]
    D -->|> H[NFT Trait Generation]
    E| I[Random Sampling]
    F --> J[Fair Distribution]
```

## Library Details**Source:**[`ChainlinkVRFImplementations.sol`](https://github.com/wenakita/OmniDragon/blob/main/contracts/chainlink/ChainlinkVRFImplementations.sol)

### Data Structures

```solidity
struct RequestStatus {
    bool fulfilled;
    uint256 randomness;
    uint256 timestamp;
}
```

## Utility Functions

### Random Number in Range

```solidity
/***@dev Calculate a randomness between min and max from a seed
 * @param _seed The random seed to use
 * @param _min The minimum value (inclusive)
 * @param _max The maximum value (inclusive)
 * @return A randomness between min and max
 */
function getRandomInRange(
    uint256 _seed,
    uint256 _min,
    uint256 _max
) internal pure returns (uint256)
```

The `getRandomInRange` function generates a randomness within a specific range [min, max] using a provided random seed.

### Multiple Random Numbers

```solidity
/***@dev Generate multiple random numbers from a seed
 * @param _seed The random seed to use
 * @param _count The number of random numbers to generate
 * @return An array of random numbers
 */
function getMultipleRandomNumbers(
    uint256 _seed,
    uint256 _count
) internal pure returns (uint256[] memory)
```

The `getMultipleRandomNumbers` function generates an array of random numbers from a single seed by using different derivations of the original seed.

### Random Indices Selection

```solidity
/***@dev Generate a random subset of indices from a range
 * @param _seed The random seed to use
 * @param _count The number of indices to select
 * @param _max The maximum index value (exclusive)
 * @return An array of random indices
 */
function getRandomIndices(
    uint256 _seed,
    uint256 _count,
    uint256 _max
) internal pure returns (uint256[] memory)
```

The `getRandomIndices` function selects a set of unique random indices from the range [0, max-1], using the Fisher-Yates shuffle algorithm to ensure unbiased selection.

### Array Shuffling

```solidity
/***@dev Shuffle an array using a random seed
 * @param _seed The random seed to use
 * @param _array The array to shuffle
 */
function shuffleArray(
    uint256 _seed,
    uint256[] memory _array
) internal pure returns (uint256[] memory)
```

The `shuffleArray` function performs a random shuffle of an array using the Fisher-Yates algorithm with a supplied random seed.

## Implementation Examples

### Jackpot Winner Selection

Use the library to select a jackpot winner based on probabilities:

```solidity
// Assuming we have a random seed from a VRF source
uint256 randomSeed = vrfRandomness;

// Select a winner from 1000 participants based on their weights (tickets)
uint256[] memory weights = new uint256[](1000);
// ... fill weights array ...

// Get the total weight
uint256 totalWeight = 0;
for (uint256 i = 0; i < weights.length; i++) {
    totalWeight += weights[i];
}

// Get a randomness in the range [1, totalWeight]
uint256 randomNum = ChainlinkVRFImplementations.getRandomInRange(
    randomSeed, 
    1, 
    totalWeight
);

// Find the winner
uint256 cumulativeWeight = 0;
uint256 winner = 0;
for (uint256 i = 0; i < weights.length; i++) {
    cumulativeWeight += weights[i];
    if (randomNum <= cumulativeWeight) {
        winner = i;
        break;
    }
}
```

### NFT Trait Generation

Generate multiple random traits for an NFT from a single seed:

```solidity
function generateNFTTraits(uint256 _tokenId, uint256 _seed) internal pure returns (uint256[] memory) {
    // Generate 5 traits for the NFT
    uint256[] memory traits = ChainlinkVRFImplementations.getMultipleRandomNumbers(_seed, 5);
    
    // Normalize the traits to specific ranges
    traits[0] = traits[0] % 100;  // background (0-99)
    traits[1] = traits[1] % 20;   // body (0-19)
    traits[2] = traits[2] % 30;   // eyes (0-29)
    traits[3] = traits[3] % 25;   // mouth (0-24)
    traits[4] = traits[4] % 15;   // accessory (0-14)
    
    return traits;
}
```

### Random Sampling

Select a random subset from a larger set without replacement:

```solidity
function selectRandomWinners(uint256 _seed, uint256 _winnerCount, uint256 _totalParticipants) internal pure returns (uint256[] memory) {
    // Get random indices representing winners
    return ChainlinkVRFImplementations.getRandomIndices(_seed, _winnerCount, _totalParticipants);
}
```

### Randomized Distribution

Ensure fair distribution of rewards by shuffling recipient addresses:

```solidity
function distributeRewards(uint256 _seed, address[] memory _recipients, uint256[] memory _amounts) internal {
    // Get indices in randomized order
    uint256[] memory indices = new uint256[](_recipients.length);
    for (uint256 i = 0; i < _recipients.length; i++) {
        indices[i] = i;
    }
    
    // Shuffle the indices
    indices = ChainlinkVRFImplementations.shuffleArray(_seed, indices);
    
    // Distribute rewards in random order
    for (uint256 i = 0; i < indices.length; i++) {
        uint256 idx = indices[i];
        // Transfer rewards to the recipient at the shuffled index
        // token.transfer(_recipients[idx], _amounts[idx]);
    }
}
```

## Security Considerations

When using this library, keep these security aspects in mind:

1.**Seed Quality**: The quality of randomness depends on the seed source. Always use a verified random source like Chainlink VRF.
2.**Modulo Bias**: For very large ranges, be aware of potential modulo bias and consider alternative approaches.
3.**Gas Limitations**: Functions that create arrays (like `getMultipleRandomNumbers`) should be used with reasonable array sizes to avoid gas limitations.
4.**Predictability**: Do not use block variables like `block.timestamp` or `block.difficulty` as seeds in production as they can be manipulated or predicted.
5.**Overflow Prevention**: The library inherits Solidity 0.8.x's built-in overflow checks for safe arithmetic operations.

## Integration with OmniDragon

Within the OmniDragon ecosystem, this library is used in multiple components:

1.**Jackpot System**: For selecting winners based on ticket weights
2.**Governance**: For random sampling in certain voting mechanisms
3.**Partner Program**: For fair distribution of rewards
4.**Cross-Chain Bridge**: For secure and unpredictable token distribution 

---
sidebar_position: 5
title: Drand
description: Detailed explanation of this concept
---

# drand Integration

The drand integration allows OmniDragon to use the decentralized randomness beacon provided by the League of Entropy's drand network as another source of verifiable randomness.

## Overview

drand is a distributed randomness beacon that provides publicly verifiable, unpredictable, and unbiased random values. OmniDragon integrates drand as part of its multi-source randomness approach, enhancing the security and reliability of the randomness used in the jackpot system.

```mermaid
flowchart TD
    A[OmniDragonVRFConsumer] -->|> B[drand Integrator]
    B| C[Verifiable Randomness]
    C -->|> D[League of Entropy Beacon]
    subgraph "drand Network"
    D| E[Node 1]
    D -->|>|> F[Node 2]
    D| G[Node 3]    endD| H[Node n]    end
```

## Key Features

-**Decentralized Randomness**: Uses randomness generated by multiple independent organizations
-**Publicly Verifiable**: Anyone can verify the correctness of the randomness
-**Threshold-Based Security**: Resistant to attacks unless a majority of participants collude
-**Regular Beacon Intervals**: Provides new randomness at regular, predictable intervals
-**Quantum-Resistant**: Uses BLS signatures for long-term security

## Integration Components

### drand Beacon Client

The drand beacon client is responsible for fetching and verifying randomness from the drand network:

```solidity
contract DrandClient {
    uint256 public constant PERIOD = 30; // seconds
    uint256 public constant GENESIS_TIME = 1595431050; // Unix timestamp
    
    // The latest randomness value fetched from drand
    bytes32 public latestRandomness;
    
    // The round number of the latest randomness
    uint256 public latestRound;
    
    // Last time the randomness was updated
    uint256 public lastUpdateTime;
    
    // Public key used for verification (compressed G1 point)
    bytes public drandPublicKey;
}
```

### DragonVRFDrandIntegrator

The DragonVRFDrandIntegrator serves as the bridge between the drand network and the OmniDragonVRFConsumer:

```solidity
contract DragonVRFDrandIntegrator is IDragonVRFIntegrator, Ownable {
    // The drand client contract
    DrandClient public drandClient;
    
    // Latest verified randomness
    uint256 public latestRandomness;
    
    // Latest round number
    uint256 public latestRound;
    
    // Authorized consumers
    mapping(address => bool) public authorizedConsumers;
    
    // Verification state
    bool public verificationEnabled;
    
    /***@dev Returns the latest randomness value
     * @return random The randomness value
     * @return round The round number
     */
    function getLatestRandomness() external view override returns (uint256 random, uint256 round) {
        return (latestRandomness, latestRound);
    }
}
```

## drand Protocol

drand operates on a threshold cryptography model where multiple independent providers participate:

1.**Setup Phase**: The network is initialized with distributed key generation
2.**Beacon Generation**: Each round, participants create partial signatures
3.**Threshold Signing**: When enough partial signatures are collected, a full signature is created
4.**Randomness Publication**: The signature is publicly shared as verifiable randomness
5.**Client Verification**: Clients can verify the signature against the public key

## Integration with OmniDragonVRFConsumer

The drand integration feeds into the OmniDragonVRFConsumer as one of multiple randomness sources:
```

```mermaid
sequenceDiagram
participant Consumer as OmniDragonVRFConsumer
participant Integrator as DragonVRFDrandIntegrator
participant Client as DrandClient
participant Network as drand Network
    Consumer ->> Integrator: getLatestRandomness()
    Integrator ->> Client: getLatestBeacon()

    alt Cache is fresh
        Client -->> Integrator: Return cached randomness
    else Cache needs update
    Client ->> Network: Request latest beacon
        Network -->> Client: Return beacon with signature
    Client ->> Client: Verify signature
    Client ->> Client: Update stored randomness
        Client -->> Integrator: Return fresh randomness
    Integrator -->> Consumer: Return randomness and round
```

## Security Considerations

The drand integration includes several security measures:

-**Signature Verification**: All randomness values are cryptographically verified
-**Time-Based Validation**: Ensures randomness is from the expected round
-**Threshold Security**: The network is secure unless a majority of participants are compromised
-**Fallback Options**: If drand is unavailable, the system can operate with other randomness sources
-**Public Auditability**: The randomness generation process can be publicly audited

## Configuration

When setting up the drand integrator in the OmniDragonVRFConsumer:

```solidity
// Add drand as a randomness source
bytes32 drandNetworkId = keccak256("DRAND");
vrfConsumer.addNetwork(
    drandNetworkId,
    drandIntegratorAddress,
    150  // Weight: 150 out of total weights
);
```

## Technical Details

### Public Key

The drand network's public key used for verification (League of Entropy mainnet):

```
868f005eb8e6e4ca0a47c8a77ceaa5309a47978a7c71bc5cce96366b5d7a569937c529eeda66c7293784a9402801af31
```

### Chain Information

-**Genesis Time**: 1595431050 (July 22, 2020)
-**Period**: 30 seconds (new randomness every 30 seconds)
-**Public Entry Point**: https://api.drand.sh/public/latest

## Resources

For more information on drand:

- [drand GitHub Repository](https://github.com/drand/drand)
- [League of Entropy Website](https://www.leagueofentropy.com/)
- [drand Documentation](https://drand.love/docs/)
- [Cloudflare's drand Service](https://drand.cloudflare.com/)

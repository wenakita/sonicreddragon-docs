/**
 * Mermaid Initialization Module
 * 
 * This module initializes Mermaid diagrams with proper dark theme support.
 */

export default function() {
  // Only run in browser context
  if (typeof window === 'undefined') {
    return;
  }

  // Wait for the document to be fully loaded
  if (document.readyState === 'complete') {
    initializeMermaid();
  } else {
    window.addEventListener('load', initializeMermaid);
  }

  function initializeMermaid() {
    // Create a more robust initialization that retries multiple times
    let attempts = 0;
    const maxAttempts = 10;
    const attemptInterval = 500; // 500ms between attempts

    function attemptInitialization() {
      attempts++;
      console.log(`Attempting to initialize Mermaid (attempt ${attempts}/${maxAttempts})...`);
      
      try {
        // Check if mermaid is available
        if (typeof window.mermaid !== 'undefined') {
          console.log('Mermaid library found. Initializing...');
          
          // Configure mermaid
          window.mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            securityLevel: 'loose',
            fontFamily: 'Inter, system-ui, -apple-system, sans-serif',
            fontSize: 14,
            themeVariables: {
              darkMode: true,
              primaryColor: '#2A2A2A',
              primaryTextColor: '#FFFFFF',
              primaryBorderColor: '#3b82f6',
              lineColor: '#3b82f6',
              secondaryColor: '#1A1A1A',
              tertiaryColor: '#0A0A0A',
              background: '#1e1e1e',
              mainBkg: '#2A2A2A',
              secondBkg: '#1A1A1A',
              textColor: '#FFFFFF',
              labelColor: '#FFFFFF',
              edgeLabelBackground: '#1A1A1A',
              clusterBkg: 'rgba(59, 130, 246, 0.1)',
              clusterBorder: '#3b82f6',
              defaultLinkColor: '#3b82f6',
            },
            flowchart: {
              htmlLabels: true,
              curve: 'basis',
            },
            sequence: {
              diagramMarginX: 50,
              diagramMarginY: 10,
              actorMargin: 50,
              width: 150,
              height: 65,
              boxMargin: 10,
              boxTextMargin: 5,
              noteMargin: 10,
              messageMargin: 35,
              mirrorActors: true,
              bottomMarginAdj: 1,
              useMaxWidth: true,
            },
          });

          // Force re-render all diagrams
          const diagrams = document.querySelectorAll('.mermaid');
          if (diagrams.length > 0) {
            console.log(`Re-rendering ${diagrams.length} Mermaid diagrams...`);
            
            // Clear any existing diagrams
            diagrams.forEach(diagram => {
              // Keep the original content
              const content = diagram.textContent;
              
              // Reset the diagram
              diagram.removeAttribute('data-processed');
              diagram.innerHTML = content;
            });
            
            // Re-render all diagrams
            window.mermaid.init(undefined, diagrams);
            
            // Add visibility class after processing
            diagrams.forEach(diagram => {
              diagram.classList.add('mermaid-visible');
            });
            
            // Add a global flag to indicate Mermaid has been initialized
            window.mermaidInitialized = true;
            
            console.log('Mermaid diagrams initialized successfully.');
          } else {
            console.warn('No Mermaid diagrams found on the page.');
          }
          
          return; // Initialization successful, exit the retry loop
        } else {
          console.warn(`Mermaid library not found (attempt ${attempts}/${maxAttempts}). Retrying...`);
          
          if (attempts < maxAttempts) {
            setTimeout(attemptInitialization, attemptInterval);
          } else {
            console.error(`Failed to initialize Mermaid after ${maxAttempts} attempts.`);
          }
        }
      } catch (error) {
        console.error('Error initializing Mermaid:', error);
        
        if (attempts < maxAttempts) {
          console.log(`Retrying initialization (attempt ${attempts}/${maxAttempts})...`);
          setTimeout(attemptInitialization, attemptInterval);
        } else {
          console.error(`Failed to initialize Mermaid after ${maxAttempts} attempts.`);
        }
      }
    }
    
    // Start the initialization process
    attemptInitialization();
    
    // Add a mutation observer to handle dynamically added Mermaid diagrams
    const observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              
              // Check if this is a Mermaid diagram
              if (element.classList && element.classList.contains('mermaid') && !element.getAttribute('data-processed')) {
                console.log('New Mermaid diagram detected. Initializing...');
                
                if (window.mermaidInitialized && window.mermaid) {
                  // Initialize the new diagram
                  window.mermaid.init(undefined, [element]);
                  element.classList.add('mermaid-visible');
                }
              }
              
              // Check for Mermaid diagrams within the added node
              const nestedDiagrams = element.querySelectorAll('.mermaid:not([data-processed])');
              if (nestedDiagrams.length > 0) {
                console.log(`${nestedDiagrams.length} new nested Mermaid diagrams detected. Initializing...`);
                
                if (window.mermaidInitialized && window.mermaid) {
                  // Initialize the new diagrams
                  window.mermaid.init(undefined, nestedDiagrams);
                  nestedDiagrams.forEach(diagram => {
                    diagram.classList.add('mermaid-visible');
                  });
                }
              }
            }
          });
        }
      });
    });
    
    // Start observing the document
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
}